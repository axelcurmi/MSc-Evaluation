IMPORTS
{
	import java.util.Arrays;
	import java.util.ArrayList;

	import com.axelcurmi.eventreplayer.Event;
}

GLOBAL
{
	VARIABLES
	{
		int minimumPacketSize = 8;
		int AES128BlockSize = 16;
		
		%%	1-19		=>	Transport layer generic (e.g., disconnect, ignore, debug, etc.)
		%%		5	=>	SSH_MSG_SERVICE_REQUEST
		%%		6	=>	SSH_MSG_SERVICE_ACCEPT
		%%	20-29		=>	Algorithm negotiation
		%%		20	=>	SSH_MSG_KEXINIT
		%%		21	=>	SSH_MSG_NEWKEYS
 		%%	30-49		=>	Key exchange method specific (numbers can be reused for different authentication methods)
		ArrayList<Integer> validCommandIdsAfterKexInit = new ArrayList<Integer>(Arrays.asList(
				1,  2,  3,  4,  7,  8,  9,  10, 11, 12,
				13, 14, 15, 16, 17, 18, 19, 21, 22, 23,
				24, 25, 26, 27, 28, 29, 30, 31, 32, 33,
				34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
				44, 45, 46, 47, 48, 49)
		);
		%% Once a party has sent a SSH_MSG_KEXINIT message for key exchange or re-exchange,
		%% until it has sent a SSH_MSG_NEWKEYS message (Section 7.3), it MUST NOT send any messages other than:
		%%	- Transport layer generic messages (1 to 19) (but SSH_MSG_SERVICE_REQUEST and SSH_MSG_SERVICE_ACCEPT MUST NOT be sent)
		%%	- Algorithm negotiation messages (20 to 29) (but further SSH_MSG_KEXINIT messages MUST NOT be sent)
		%%	- Specific key exchange method messages (30 to 49)
	}

	EVENTS
	{
		before_connect(
			Event e,
			boolean hostInSystemHostKeys,
			boolean hostInHostKeys
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("BEFORE") &&
				e1.getWhat().equals("connect")
			} where {
				hostInSystemHostKeys = (boolean)e1.getWatch().get("host_in_system_host_keys");
				hostInHostKeys = (boolean)e1.getWatch().get("host_in_host_keys");
				e = e1;
			}

		sshException_connect(
			Event e
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("SSHException") &&
				e1.getWhat().equals("connect")
			} where {
				e = e1;
			}

		after_connect(
			Event e
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("AFTER") &&
				e1.getWhat().equals("connect")
			} where {
				e = e1;
			}

		before_send_kex_init(
			Event e, ArrayList<String> preferredCiphers
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("BEFORE") &&
				e1.getWhat().equals("_send_kex_init")
			} where {
				preferredCiphers = (ArrayList<String>)e1.getWatch().get("preferred_ciphers");
				e = e1;
			}

		before_read_message(
			Event e, boolean isMACEngineSet
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("BEFORE") &&
				e1.getWhat().equals("read_message")
			} where {
				isMACEngineSet = (boolean)e1.getWatch().get("mac_engine_set");
				e = e1;
			}
		
		eof_read_message(
			Event e
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("EOFError") &&
				e1.getWhat().equals("read_message")
			} where {
				e = e1;
			}
		
		after_read_message(
			Event e
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("AFTER") &&
				e1.getWhat().equals("read_message")
			} where {
				e = e1;
			}

		before_constant_time_bytes_eq(
			Event e
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("BEFORE") &&
				e1.getWhat().equals("constant_time_bytes_eq")
			} where {
				e = e1;
			}
			
		before_parse_kexdh_reply(
			Event e
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("BEFORE") &&
				e1.getWhat().equals("_parse_kexdh_reply")
			} where {
				e = e1;
			}
		
		after_parse_kexdh_reply(
			Event e
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("AFTER") &&
				e1.getWhat().equals("_parse_kexdh_reply")
			} where {
				e = e1;
			}
		
		after_parse_newkeys(
			Event e,
			boolean bytesEqual
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("AFTER") &&
				e1.getWhat().equals("_parse_newkeys")
			} where {
				bytesEqual = (boolean)e1.getWatch().get("bytes_equal");
				e = e1;
			}
			
		before_verify_ssh_sig_aspect(
			Event e
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("BEFORE") &&
				e1.getWhat().equals("verify_ssh_sig_aspect")
			} where {
				e = e1;
			}
			
		after_build_packet(
			Event e,
			double packetLength,
			double paddingLength
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("AFTER") &&
				e1.getWhat().equals("_build_packet")
			} where {
				packetLength = (double)e1.getWatch().get("packet_length");
				paddingLength = (double)e1.getWatch().get("padding_length");
				e = e1;
			}
			
		sshexception_check_banner(
			Event e
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("SSHException") &&
				e1.getWhat().equals("_check_banner")
			} where {
				e = e1;
			}
			
		after_check_banner(
			Event e,
			String banner
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("AFTER") &&
				e1.getWhat().equals("_check_banner")
			} where {
				banner = ((String)e1.getWatch().get("banner")).replace("SSH-", "");
				e = e1;
			}
			
		before_send_message(
			Event e,
			int commandId
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("BEFORE") &&
				e1.getWhat().equals("send_message")
			} where {
				commandId = ((Double)e1.getWatch().get("command_id")).intValue();
				e = e1;
			}

		before_request_auth(
			Event e
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("BEFORE") &&
				e1.getWhat().equals("_request_auth")
			} where {
				e = e1;
			}

		before_parse_userauth_success(
			Event e
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("BEFORE") &&
				e1.getWhat().equals("_parse_userauth_success")
			} where {
				e = e1;
			}

		before_parse_userauth_failure(
			Event e
		) = { Event e1.replay() }
			filter {
				e1.getWhen().equals("BEFORE") &&
				e1.getWhat().equals("_parse_userauth_failure")
			} where {
				e = e1;
			}
	}

	PROPERTY noneCipherProperty
	{
		STATES
		{
			BAD { bad }
			STARTING { good }
		}
		
		TRANSITIONS
		{
			good -> bad [ before_send_kex_init \ preferredCiphers.contains("none") ]
		}
	}
	
	PROPERTY newHostProperty
	{
		STATES
		{
			BAD { noExceptionThrown }
			NORMAL { shouldThrowException }
			STARTING { start }
		}
		
		TRANSITIONS
		{
			start -> shouldThrowException [ before_connect \ !(hostInSystemHostKeys || hostInHostKeys) ]
			shouldThrowException -> start [ sshException_connect ]
			shouldThrowException -> noExceptionThrown [ after_connect ]
		}
	}
	
	PROPERTY checkMACProperty
	{
		STATES
		{
			BAD { notCheckedMAC }
			NORMAL { shouldCheckMAC }
			STARTING { start }
		}

		TRANSITIONS
		{
			start -> shouldCheckMAC [ before_read_message \ isMACEngineSet ]
			shouldCheckMAC -> start [ before_constant_time_bytes_eq ]
			shouldCheckMAC -> start [ eof_read_message ]
			shouldCheckMAC -> notCheckedMAC [ after_read_message ]
		}
	}
	
	PROPERTY verifyHostKeyProperty
	{
		STATES
		{
			BAD { notVerifiedHostKey }
			NORMAL { shouldVerifyHostKey }
			STARTING { start }
		}

		TRANSITIONS
		{
			start -> shouldVerifyHostKey [ before_parse_kexdh_reply ]
			shouldVerifyHostKey -> start [ before_verify_ssh_sig_aspect ]
			shouldVerifyHostKey -> notVerifiedHostKey [ after_parse_kexdh_reply ]
		}
	}

	PROPERTY clearedDHValuesProperty
	{
		STATES
		{
			BAD { bad }
			STARTING { start }
		}
		
		TRANSITIONS
		{
			start -> bad [ after_parse_newkeys \ bytesEqual \ System.out.println("--> " + e.toString()); ]
		}
	}
	
	PROPERTY paddingSizeProperty
	{
		STATES
		{
			BAD { bad }
			STARTING { start }
		}
		
		TRANSITIONS
		{
			start -> bad [ after_build_packet \ paddingLength < 4 ]
		}
	}
	
	PROPERTY packetSizeProperty
	{
		STATES
		{
			BAD { bad }
			NORMAL { encryptedMessages }
			STARTING { unencryptedMessages }
		}
		
		TRANSITIONS
		{
			unencryptedMessages -> encryptedMessages [ after_parse_newkeys ]
			unencryptedMessages -> bad [ after_build_packet \ packetLength % minimumPacketSize != 0 \ System.out.println("--> " + e.toString()); ]
			encryptedMessages -> bad [ after_build_packet \ packetLength % AES128BlockSize != 0 \ System.out.println("--> " + e.toString()); ]
		}
	}
	
	PROPERTY bannerProperty
	{
		STATES
		{
			BAD { noExceptionThrown }
			NORMAL { exceptionThrown }
			STARTING { start }
		}
		
		TRANSITIONS
		{
			start -> exceptionThrown [ sshexception_check_banner ]
			start -> noExceptionThrown [ after_check_banner \ !(banner.startsWith("2.0") || banner.startsWith("1.99")) \
				System.out.println("--> " + e.toString()); ]
		}
	}
	
	PROPERTY invalidMessagesProperty
	{
		STATES
		{
			BAD { invalidMessageSent }
			NORMAL { kexInitSent }
			STARTING { start }
		}

		TRANSITIONS
		{
			start -> kexInitSent [ before_send_message \ commandId == 20 ] %% SSH_MSG_KEXINIT
			kexInitSent -> start [ before_send_message \ commandId == 21 ] %% SSH_MSG_NEWKEYS
			kexInitSent -> invalidMessageSent [ before_send_message \ !validCommandIdsAfterKexInit.contains(commandId) \ System.out.println("--> " + e.toString()); ]
		}
	}
	
	PROPERTY subsequentAuthRequestsProperty
	{
		STATES
		{
			BAD { illegalRequestSent }
			NORMAL { cannotSentRequest }
			STARTING { canSendRequest }
		}
		
		TRANSITIONS
		{
			canSendRequest -> cannotSentRequest [ before_request_auth ]
			cannotSentRequest -> canSendRequest [ before_parse_userauth_success ]
			cannotSentRequest -> canSendRequest [ before_parse_userauth_failure ]
			cannotSentRequest -> illegalRequestSent [ before_request_auth ]
		}
	}
}